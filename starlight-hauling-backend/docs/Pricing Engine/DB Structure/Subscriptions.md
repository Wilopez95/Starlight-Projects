# Subscriptions DB Tables structure

## `subscription_service_items_schedule` table

### Motivation

    1. When CSR sets the new rate for the service via bulk update
       feature he sets an effective date.
       So he can set the new price starting from tomorrow and then again
       set the new price starting from next week and so on.
    2. When CSR updates the service item on Subscription Entry Form
       he sets an effective date for the change. For example at first edit CSR
       has changed quantity and set effective date for the next month.
       But then he can also change the frequency of servicing
       and set an effective date for this change in past (e.g. last Monday).
       This last change shouldn't change quantity for the service until next month
       as has been specified during quantity change.
    3. So usage of historical table is a dirty and hacky way
       and adds more complexity to understand the logic
       and structure because in general historical tables
       are only entity state snapshots.
       And when we add more logic on that -
       it results in misunderstanding between team members

### DB Structure

```sql
CREATE TABLE subscription_service_items_schedule(
  id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,

  subscription_id INTEGER NOT NULL,
  subscription_service_item_id INTEGER NOT NULL,
  billable_service_id INTEGER NOT NULL,
  material_id INTEGER DEFAULT NULL,
  price_id INTEGER NOT NULL,

  billing_cycle TEXT NOT NULL,
  frequency_id INTEGER DEFAULT NULL,
  service_days_of_week JSONB DEFAULT NULL,

  quantity INTEGER DEFAULT NULL,
  override_price BOOLEAN DEFAULT FALSE,
  override_proration BOOLEAN DEFAULT FALSE,

  price bigint NOT NULL, -- show as decimal depending on locale on FE, at least 6 fractional digits
  overridden_price bigint NOT NULL, -- when override_price
  next_price bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  amount bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  prorated_amount bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  overridden_prorated_amount bigint, -- when override_proration
  total bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits

  -- transition between billing periods must split records
  -- so if this item has dates range limited by start_date and end_date
  -- that intersects with multiple billing periods
  -- then we have to split this item into multiple records
  -- and all of result records must be in range
  -- of appropriate billing period
  -- (or start_date/end_date if it restricts more)
  -- the same logic applies to invoicing - start_date and end_date of
  -- an invoice both can split this record onto multiple parts
  -- limited by own date range and invoice date range
  start_at timestamp without time zone NOT NULL DEFAULT CURRENT_TIMESTAMP,
  end_at timestamp without time zone DEFAULT NULL,

  invoiced_at timestamp without time zone DEFAULT NULL,
  paid_at timestamp without time zone DEFAULT NULL,

  created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,

  PRIMARY KEY ("id"),
  FOREIGN KEY ("subscription_id") REFERENCES "subscriptions"("id") MATCH SIMPLE
      ON update NO ACTION
      ON delete RESTRICT,
  FOREIGN KEY ("subscription_service_item_id") REFERENCES "subscription_service_item"("id") MATCH SIMPLE
      ON update NO ACTION
      ON delete RESTRICT,
  FOREIGN KEY ("billable_service_id") REFERENCES "billable_services"("id") MATCH SIMPLE
      ON update NO ACTION
      ON delete RESTRICT,
  FOREIGN KEY ("material_id") REFERENCES "materials"("id") MATCH SIMPLE
      ON update NO ACTION
      ON delete RESTRICT,
  FOREIGN KEY ("price_id") REFERENCES "prices"("id") MATCH SIMPLE
      ON update NO ACTION
      ON delete RESTRICT,

  CHECK(billing_cycle <@ (ARRAY['daily'::TEXT, 'weekly'::TEXT, 'monthly'::TEXT, '28days'::TEXT, 'quarterly'::TEXT, 'yearly'::TEXT]))
);
CREATE INDEX "subscription_service_items_schedule_start_at" ON "subscription_service_items_schedule" ("start_at" DESC);
CREATE INDEX "subscription_service_items_schedule_end_at" ON "subscription_service_items_schedule" ("end_at" ASC NULLS LAST);
```

## `subscription_recurring_line_items_schedule` table

### Motivation

the same as for `subscription_service_items_schedule` table

### DB Structure

```sql
CREATE TABLE subscription_recurring_line_items_schedule(
  id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,

  subscription_id INTEGER NOT NULL,
  subscription_recurring_line_item_id INTEGER NOT NULL,
  billable_line_item_id INTEGER NOT NULL,
  price_id INTEGER NOT NULL,

  billing_cycle TEXT NOT NULL,

  quantity INTEGER DEFAULT NULL,
  override_price BOOLEAN DEFAULT FALSE,
  override_proration BOOLEAN DEFAULT FALSE, -- when override proration

  price bigint NOT NULL, -- show as decimal depending on locale on FE, at least 6 fractional digits
  overridden_price bigint NOT NULL, -- when override_price
  next_price bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  amount bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  prorated_amount bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  overridden_prorated_amount bigint, -- when override_proration
  total bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits

  -- transition between billing periods must split records
  -- so if this item has dates range limited by start_date and end_date
  -- that intersects with multiple billing periods
  -- then we have to split this item into multiple records
  -- and all of result records must be in range
  -- of appropriate billing period
  -- (or start_date/end_date if it restricts more)
  -- the same logic applies to invoicing - start_date and end_date of
  -- an invoice both can split this record onto multiple parts
  -- limited by own date range and invoice date range
  start_at timestamp without time zone NOT NULL DEFAULT CURRENT_TIMESTAMP,
  end_at timestamp without time zone DEFAULT NULL,

  invoiced_at timestamp without time zone DEFAULT NULL,
  paid_at timestamp without time zone DEFAULT NULL,

  created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,

  PRIMARY KEY ("id"),
  FOREIGN KEY ("subscription_id") REFERENCES "subscriptions"("id") MATCH SIMPLE
      ON update NO ACTION
      ON delete RESTRICT,
  FOREIGN KEY ("subscription_recurring_line_item_id") REFERENCES "subscription_line_items"("id") MATCH SIMPLE
      ON update NO ACTION
      ON delete RESTRICT,
  FOREIGN KEY ("billable_line_item_id") REFERENCES "billable_line_items"("id") MATCH SIMPLE
      ON update NO ACTION
      ON delete RESTRICT,
  FOREIGN KEY ("price_id") REFERENCES "prices"("id") MATCH SIMPLE
      ON update NO ACTION
      ON delete RESTRICT,

  CHECK(billing_cycle <@ (ARRAY['daily'::TEXT, 'weekly'::TEXT, 'monthly'::TEXT, '28days'::TEXT, 'quarterly'::TEXT, 'yearly'::TEXT]))
);
CREATE INDEX "subscription_recurring_line_items_schedule_start_at" ON "subscription_recurring_line_items_schedule" ("start_at" DESC);
CREATE INDEX "subscription_recurring_line_items_schedule_end_at" ON "subscription_recurring_line_items_schedule" ("end_at" ASC NULLS LAST);
```

## `subscriptions_periods` table

### Motivation

    `subscription_recurring_line_items_schedule`,
    `subscription_orders`,
    `subscription_orders_line_items`,
    `subscription_surcharge_items` tables and taxes

### DB Structure

```sql
CREATE TABLE subscriptions_periods (
  id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY,

  subscription_id INTEGER NOT NULL,
  price_group_historical_id INTEGER NOT NULL,

  status TEXT NOT NULL,

  billing_cycle TEXT NOT NULL,
  billing_type TEXT NOT NULL,

  override_proration BOOLEAN DEFAULT FALSE,

  recurring_services_amount bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  recurring_services_prorated_amount bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  recurring_services_overridden_prorated_amount bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  recurring_services_total bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits

  recurring_line_items_amount bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  recurring_line_items_overridden_amount bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  recurring_line_items_total bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  recurring_line_items_overridden_total bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits

  recurring_amount bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  recurring_overridden_amount bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  recurring_total bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  recurring_overridden_total bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits

  -- includes total price for subscription orders
  -- that fall in this interval their line items
  one_time_amount bigint,
  one_time_overridden_amount bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  one_time_total bigint,
  one_time_overridden_total bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits

  before_taxes_grand_total bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  before_taxes_overridden_grand_total bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  grand_total bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits
  overridden_grand_total bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits

  next_grand_total bigint, -- show as decimal depending on locale on FE, at least 6 fractional digits

  -- transition between billing periods must split records
  -- so if this item has dates range limited by start_date and end_date
  -- that intersects with multiple billing periods
  -- then we have to split this item into multiple records
  -- and all of result records must be in range
  -- of appropriate billing period
  -- (or start_date/end_date if it restricts more)
  -- the same logic applies to invoicing - start_date and end_date of
  -- an invoice both can split this record onto multiple parts
  -- limited by own date range and invoice date range
  start_at timestamp without time zone NOT NULL DEFAULT CURRENT_TIMESTAMP,
  end_at timestamp without time zone DEFAULT NULL,

  invoiced_at timestamp without time zone DEFAULT NULL,
  paid_at timestamp without time zone DEFAULT NULL,

  created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,

  PRIMARY KEY ("id"),

  FOREIGN KEY ("subscription_id") REFERENCES "subscriptions"("id") MATCH SIMPLE
      ON update NO ACTION
      ON delete RESTRICT,
  FOREIGN KEY ("price_group_historical_id") REFERENCES "price_groups_historical"("id") MATCH SIMPLE
      ON update NO ACTION
      ON delete RESTRICT,

  CHECK(status <@ (ARRAY['active'::TEXT, 'onHold'::TEXT, 'closed'::TEXT, 'draft'::TEXT])),
  CHECK(billing_cycle <@ (ARRAY['daily'::TEXT, 'weekly'::TEXT, 'monthly'::TEXT, '28days'::TEXT, 'quarterly'::TEXT, 'yearly'::TEXT])),
  CHECK(billing_type <@ (ARRAY['arrears'::TEXT, 'inAdvance'::TEXT]))
);
CREATE INDEX "subscriptions_periods_start_at" ON "subscriptions_periods" ("start_at" DESC);
CREATE INDEX "subscriptions_periods_end_at" ON "subscriptions_periods" ("end_at" ASC NULLS LAST);
CREATE INDEX "subscriptions_periods_non_invoiced" ON "subscriptions_periods" ("invoiced_at") WHERE "invoiced_at" IS NULL;
CREATE INDEX "subscriptions_periods_non_paid" ON "subscriptions_periods" ("paid_at") WHERE "paid_at" IS NULL;
```
