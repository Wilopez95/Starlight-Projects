import sgMail from '@sendgrid/mail';
import isEmpty from 'lodash/isEmpty.js';
import { SENDGRID_SMTP_API_KEY_ID, SENDGRID_SENDER_EMAIL } from '../config.js';

sgMail.setApiKey(SENDGRID_SMTP_API_KEY_ID);

export const sendTextEmail = (
  to,
  subject,
  html,
  from = SENDGRID_SENDER_EMAIL,
  replyTo = SENDGRID_SENDER_EMAIL,
  copyTo,
) => {
  const receivers = copyTo ? [to, copyTo] : [to];
  receivers.forEach(receiver =>
    sgMail.send({
      from,
      to: receiver,
      subject,
      html,
      replyTo,
    }),
  );
};

/**
 * Send an email to the user with the subject and body specified in the mailSettings object
 * @param {string} email - The email address of the user who placed the order.
 * @param {Object} mailSettings - An object containing the subject and body of the email.
 * { servicesSubject, servicesBody, servicesFrom, servicesReplyTo, servicesSendCopyTo, domain}
 * @returns {Promise} - A promise that resolves when the email has been sent.
 */
export const sendOrderNotification = async (email, mailSettings = {}) => {
  const {
    servicesSubject,
    servicesBody,
    servicesFrom,
    servicesReplyTo,
    servicesSendCopyTo,
    domain,
  } = mailSettings;
  // if the domain settings are empty, we are sending the emails from the default email otherwise we are sending them from the domain email
  // the default email in production is notify@starlightsoftware.io set by `SENDGRID_SENDER_EMAIL`
  const actualFrom = isEmpty(domain) ? SENDGRID_SENDER_EMAIL : `${servicesFrom}@${domain}`;
  // all replyTo fields no longer required to be a hostname only if the domain is not added
  // if there is a domain the reply to should be the initial part of the email like it was previously (before the @).
  const actualReplyTo = isEmpty(domain) ? servicesReplyTo : `${servicesReplyTo}@${domain}`;

  await sendTextEmail(
    email,
    servicesSubject,
    servicesBody,
    actualFrom,
    actualReplyTo,
    servicesSendCopyTo,
  );
};

export const sendRecurrentOrderFailureNotification = async (
  { serviceDate, recurrentOrderId, customerId },
  mailSettings = {},
) => {
  const { notificationEmails = [] } = mailSettings;

  await sendTextEmail(
    notificationEmails,
    'Failure of recurrent orders generation',
    `Recurrent order for ${serviceDate} failed to generate automatically.
        Please check recurrent template ID ${recurrentOrderId}, customer ID ${customerId}.`,
  );
};

/**
 * Send an email to a contractor with their autogenerated password
 * @param {string} email - The email address of the recipient.
 * @param {string} password - The password that was generated for the user.
 * @returns {Promise} - A promise that resolves when the email has been sent.
 */
export const sendContractorPassword = async (email, password) => {
  const body = `Here is your autogenerated password ${password}

Thanks,

Starlight Team`;

  await sendTextEmail(email, 'Account Password Generated', body, undefined, undefined, undefined);
};

export const sendProspectReminderEmail = async (email, customerName, subscriptionDraftId) => {
  const body = `Please ensure to send the offer to ${customerName} , ${subscriptionDraftId}\n

  Please do not respond to this email`;

  await sendTextEmail(email, 'Send offer', body);
};

export const sendAnnualReminderEmail = async (email, customerName, subscriptionId) => {
  const body = `Please ensure to contact ${customerName}, subscription ${subscriptionId}, on the upcoming event\n

Please do not respond to this email`;

  await sendTextEmail(email, 'Annual Event Reminder', body);
};

export const sendFileLink = async (email, fileLink) => {
  const body = `<a href="${fileLink}">File download link</a>`;

  await sendTextEmail(email, 'File download link', body);
};

const generatingSubscriptionEventBody = (body, subscriptionIds) =>
  body.replace(/\{\{\s?subscriptionsIds\s?\}\}/, subscriptionIds);

export const sendEndingSubscriptionNotification = async (
  email,
  subscriptionIds,
  mailSettings = {},
) => {
  const { subscriptionsEndSubject, subscriptionsEndBody, subscriptionsEndFrom, domain } =
    mailSettings;
  await sendTextEmail(
    email,
    subscriptionsEndSubject,
    generatingSubscriptionEventBody(subscriptionsEndBody, subscriptionIds),
    `${subscriptionsEndFrom}@${domain}`,
  );
};

export const sendResumeSubscriptionNotification = async (
  email,
  subscriptionIds,
  mailSettings = {},
) => {
  const { subscriptionsResumeSubject, subscriptionsResumeBody, subscriptionsResumeFrom, domain } =
    mailSettings;
  await sendTextEmail(
    email,
    subscriptionsResumeSubject,
    generatingSubscriptionEventBody(subscriptionsResumeBody, subscriptionIds),
    `${subscriptionsResumeFrom}@${domain}`,
  );
};

export const generatingOnHoldCustomerEventBody = (
  body,
  subscriptionIds,
  recurringOrdersIds,
  customerName,
) =>
  body
    .replace(/\{\{\s?subscriptionsIds\s?\}\}/, subscriptionIds?.length ? subscriptionIds : '')
    .replace(
      /\{\{\s?recurringOrdersIds\s?\}\}/,
      recurringOrdersIds?.length ? recurringOrdersIds : '',
    )
    .replace(/\{\{\s?customerName\s?\}\}/, customerName);

export const sendTermsAndConditionsEmail = async (email, businessUnit, url, mailSettings = {}) => {
  const {
    termsAndConditionsFrom,
    termsAndConditionsReplyTo,
    termsAndConditionsSubject,
    termsAndConditionsBody,
  } = mailSettings;
  const body = termsAndConditionsBody
    .replace(
      /\{\{\s?bu_name_line_1\s?\}\}/,
      `<b>${businessUnit.nameLine1 ? businessUnit.nameLine1 : ''}</b>`,
    )
    .replace(
      /\{\{\s?bu_name_line_2\s?\}\}/,
      `<b>${businessUnit.nameLine2 ? businessUnit.nameLine2 : ''}</b>`,
    )
    .replace(/\{\{\s?tc_url\s?\}\}/, `<a href="${url}">Terms And Conditions Link</a>`);
  const subj = !isEmpty(termsAndConditionsSubject)
    ? termsAndConditionsSubject
    : 'Terms and Conditions';
  await sendTextEmail(
    email,
    subj,
    body,
    termsAndConditionsFrom,
    termsAndConditionsReplyTo,
    undefined,
  );
};
